// Generated by LiveScript 1.3.1
(function(){
  var getColorAlt, CENS, SA, QS, QSA, local, GradientEditor, ldcp;
  getColorAlt = function(c){
    var colorAlt, ref$;
    c = ldColor.hcl(c);
    return colorAlt = (ref$ = import$({}, c), ref$.l = c.l > 50
      ? c.l - 20
      : c.l + 20, ref$);
  };
  CENS = function(n){
    return document.createElementNS("http://www.w3.org/2000/svg", n);
  };
  SA = function(n, o){
    var k, v, results$ = [];
    for (k in o) {
      v = o[k];
      results$.push(n.setAttribute(k, v));
    }
    return results$;
  };
  QS = function(n, s){
    return n.querySelector(s);
  };
  QSA = function(n, s){
    return Array.from(n.querySelectorAll(s));
  };
  local = {};
  window.GradientEditor = GradientEditor = function(opt){
    var root, gradient, angle, funcs, this$ = this;
    opt == null && (opt = {});
    this.root = root = typeof opt.root === typeof ''
      ? opt.root = QS(document, opt.root)
      : opt.root;
    this.root.classList.add('ldgradient');
    import$(this, {
      opt: opt,
      id: opt.id || "ldg-" + Math.random().toString(36).substring(2),
      dir: opt.dir || 0,
      angle: {},
      state: {
        drag: false,
        slider: false,
        knob: false,
        active: false,
        hover: false
      }
    });
    if (!opt.colors || opt.colors.length < 2) {
      opt.colors = QSA(this.root, 'g.ldg-colors circle').map(function(it){
        return it.getAttribute('fill');
      });
    }
    if (opt.colors.length < 2) {
      opt.colors = ['#eee', '#ddd'];
    }
    this.colors = opt.colors.map(function(d, i){
      var ret;
      ret = typeof d === 'string' ? ldColor.hsl(d) : d;
      if (!(ret.offset != null)) {
        ret.offset = i / (opt.colors.length - 1);
      }
      return ret;
    });
    if (!this.opt.manualDom) {
      this.build();
    }
    this.el = {
      bar: QS(this.root, '.ldg-bar'),
      colors: QS(this.root, '.ldg-colors'),
      board: QS(this.root, '.ldg-board'),
      gradient: gradient = QS(this.root, 'linearGradient'),
      texts: QS(this.root, '.ldg-texts'),
      percent: QS(this.root, '.ldg-percent'),
      hex: QS(this.root, '.ldg-hex')
    };
    this.setIdx(0);
    this.buildDots();
    this.updateGradient();
    angle = function(e, knob){
      var box, ref$, x, y, dx, dy, a;
      knob == null && (knob = true);
      box = this$.root.getBoundingClientRect();
      ref$ = [box.left + box.width * 0.5, box.top + box.width * 0.5], x = ref$[0], y = ref$[1];
      ref$ = [e.clientX - x, e.clientY - y], dx = ref$[0], dy = ref$[1];
      a = 180 * Math.acos(60 * dy / Math.sqrt((dx * dx + dy * dy) * (60 * 60))) / Math.PI;
      if (knob) {
        a = 180 - a;
      }
      if (knob && dx < 0) {
        a = 360 - a;
      }
      if (!knob) {
        a <= 60 || (a = 60);
      }
      if (!knob && dx > 0) {
        a = -a;
      }
      return a;
    };
    funcs = {
      knob: {
        cancel: function(e){
          var a;
          this$.state.knob = false;
          if (!isNaN(a = angle(e) - this$.angle.init + this$.dir)) {
            this$.dir = a;
          }
          return document.removeEventListener('mouseup', funcs.knob.cancel);
        }
      },
      bar: {
        move: function(e){
          var a, offset;
          if (this$.dot) {
            this$.state.drag = true;
            a = angle(e, false);
            this$.dot.style.transform = "rotate(" + a + "deg)";
            this$.colors[+this$.dot.getAttribute('data-idx')].offset = offset = (60 - a) / 120;
            this$.el.percent.textContent = Math.round(offset * 100);
            return this$.updateGradient();
          }
        },
        cancel: function(e){
          this$.dot = null;
          if (!this$.state.hover) {
            this$.debounce = setTimeout(function(){
              return this$.toggle(false);
            }, 300);
          }
          document.removeEventListener('mousemove', funcs.bar.move);
          return document.removeEventListener('mouseup', funcs.bar.cancel);
        }
      }
    };
    this.root.addEventListener('mouseover', function(){
      this$.state.hover = true;
      if (!this$.state.active) {
        return this$.toggle(true);
      }
    });
    this.root.addEventListener('mouseout', function(){
      this$.state.hover = false;
      if (!this$.dot && !this$.locked) {
        return this$.debounce = setTimeout(function(){
          return this$.toggle(false);
        }, 300);
      }
    });
    this.root.addEventListener('mousedown', function(e){
      var ref$;
      if ((ref$ = this$.el.board) === e.target || ref$ === e.target.parentNode) {
        this$.state.knob = true;
        this$.angle.init = angle(e);
        return document.addEventListener('mouseup', funcs.knob.cancel);
      } else if (e.target.parentNode.parentNode === this$.el.colors) {
        this$.dot = e.target.parentNode;
        this$.setIdx(+this$.dot.getAttribute('data-idx'));
        this$.el.hex.textContent = ldColor.hex(this$.colors[this$.idx]);
        this$.el.percent.textContent = Math.round(this$.colors[this$.idx].offset * 100);
        document.addEventListener('mousemove', funcs.bar.move);
        return document.addEventListener('mouseup', funcs.bar.cancel);
      }
    });
    this.root.addEventListener('mousemove', function(e){
      var a;
      if (this$.state.knob) {
        if (isNaN(a = angle(e) - this$.angle.init + this$.dir)) {
          return;
        }
        return this$.el.board.setAttribute('transform', "rotate(" + a + " 50 50)");
      }
    });
    this.root.addEventListener('click', function(e){
      var act, nc;
      act = e.target.getAttribute('data-action') || e.target.parentNode.getAttribute('data-action');
      if (this$.el.colors === e.target.parentNode.parentNode && !this$.state.drag) {
        this$.setIdx(+e.target.parentNode.getAttribute('data-idx'));
        if (local.client && local.client !== this$) {
          local.client.lock(false);
        }
        local.client = this$;
        this$.lock(true);
        if (!(typeof ldcp != 'undefined' && ldcp !== null)) {
          return;
        }
        ldcp.setPalette({
          colors: this$.colors
        });
        ldcp.setIdx(this$.idx);
        ldcp.toggle(true, e.target);
        e.stopPropagation();
      }
      this$.state.drag = false;
      if (act === 'dup') {
        nc = import$({}, this$.colors[this$.idx]);
        nc.offset = (nc.offset + this$.colors[this$.idx + (this$.idx < this$.colors.length - 1
          ? 1
          : -1)].offset) / 2;
        this$.colors.splice(this$.idx, 0, nc);
        if (this$.idx === this$.colors.length - 1) {
          this$.setIdx(this$.idx + 1);
        }
      } else if (act === 'del' && this$.colors.length > 2) {
        this$.colors.splice(this$.idx, 1);
        if (this$.idx > 0) {
          this$.setIdx(this$.idx - 1);
        }
      } else {
        return;
      }
      this$.updateGradient();
      return this$.buildDots(true);
    });
    return this;
  };
  GradientEditor.prototype = import$(Object.create(Object.prototype), {
    build: function(){
      return this.root.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"-10 10 120 120\" preserveAspectRatio=\"xMidYMid\">\n  <linearGradient id=\"" + this.id + "-gradient\" x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\"></linearGradient>\n  <path class=\"ldg-bar\" d=\"M-1.962 80 A60 60 1 0 0 101.962 80\" fill=\"none\" stroke=\"#eeeff1\" stroke-width=\"1\"/>\n  <g class=\"ldg-board\" transform=\"rotate(" + this.dir + " 50 50)\">\n    <circle cx=\"50\" cy=\"50\" r=\"50\" fill=\"url(#" + this.id + "-gradient)\"/><use href=\"#ldg-knob\"/>\n  </g>\n  <g class=\"ldg-texts\" transform=\"translate(50 50)\">\n    <text class=\"ldg-hex\" dx=\"-0.2em\" dy=\"-0.7em\"></text>\n    <text dx=\"0.1em\" dy=\"0.6em\">\n      <tspan class=\"ldg-percent\"></tspan><tspan font-size=\"0.7em\">%</tspan>\n    </text>\n    <text dy=\"1.4em\" class=\"ldg-btn\">\n      <tspan data-action=\"dup\">+ </tspan><tspan data-action=\"del\"> &times;</tspan>\n    </text>\n  </g>\n  <g class=\"ldg-colors\"></g>\n</svg>";
    },
    buildDots: function(toggled){
      var cs, i$, i, to$, color, colorAlt, ref$, g, c1, c2;
      toggled == null && (toggled = false);
      cs = this.el.colors;
      for (i$ = cs.childNodes.length - 1; i$ >= 0; --i$) {
        i = i$;
        cs.removeChild(cs.childNodes[i]);
      }
      for (i$ = 0, to$ = this.colors.length; i$ < to$; ++i$) {
        i = i$;
        color = this.colors[i];
        colorAlt = getColorAlt(color);
        ref$ = ['g', 'circle', 'circle'].map(CENS), g = ref$[0], c1 = ref$[1], c2 = ref$[2];
        g.appendChild(c2);
        g.appendChild(c1);
        SA(c2, {
          cx: 50,
          cy: 110,
          r: 11,
          fill: '#fff',
          "fill-opacity": 0
        });
        SA(c1, {
          cx: 50,
          cy: 110,
          r: 6,
          stroke: ldColor.web(colorAlt),
          "stroke-width": 1,
          fill: ldColor.web(color)
        });
        c1.classList.add('ldg-dot');
        g.setAttribute('data-idx', i);
        g.style.transform = "rotate(" + (-15 * (this.colors.length - 1) * 0.5 + i * 15) + "deg)";
        this.el.colors.appendChild(g);
      }
      return this.toggleSlider(toggled);
    },
    updateGradient: function(){
      var g, i$, i, colors, res$, ref$, len$, c, s, results$ = [];
      g = this.el.gradient;
      for (i$ = g.childNodes.length - 1; i$ >= 0; --i$) {
        i = i$;
        g.removeChild(g.childNodes[i]);
      }
      res$ = [];
      for (i$ = 0, len$ = (ref$ = this.colors).length; i$ < len$; ++i$) {
        c = ref$[i$];
        res$.push(c);
      }
      colors = res$;
      colors.sort(function(a, b){
        return a.offset - b.offset;
      });
      for (i$ = 0, len$ = colors.length; i$ < len$; ++i$) {
        c = colors[i$];
        s = CENS('stop');
        SA(s, {
          "stop-color": ldColor.web(c),
          offset: c.offset
        });
        results$.push(g.appendChild(s));
      }
      return results$;
    },
    lock: function(v){
      this.locked = v;
      if (v) {
        this.toggle(true);
      }
      if (!v && !this.state.hover) {
        return this.toggle(false);
      }
    },
    setIdx: function(idx){
      var c;
      this.idx = idx;
      c = this.colors[this.idx];
      this.el.hex.textContent = ldColor.hex(c);
      return this.el.percent.textContent = Math.round(c.offset * 100);
    },
    setColor: function(c){
      var cAlt;
      this.colors[this.idx] = (c.offset = this.colors[this.idx].offset, c);
      cAlt = getColorAlt(c);
      SA(this.el.colors.querySelector("g:nth-child(" + (1 + this.idx) + ") .ldg-dot"), {
        fill: ldColor.web(c),
        stroke: ldColor.web(cAlt)
      });
      this.el.hex.textContent = ldColor.hex(c);
      return this.updateGradient();
    },
    toggle: function(v){
      var this$ = this;
      if (this.locked) {
        return;
      }
      if (!(v != null)) {
        this.state.active = v = !this.state.active;
      }
      if (this.debounce) {
        clearTimeout(this.debounce);
        this.debounce = null;
      }
      this.root.classList[v ? 'add' : 'remove']('active');
      setTimeout(function(){
        return this$.root.classList[v ? 'add' : 'remove']('on');
      }, 300);
      return this.toggleSlider(v);
    },
    getDots: function(){
      return QSA(this.el.colors, 'g');
    },
    toggleSlider: function(v){
      var cs, order, offsets, i$, to$, i, n, idx;
      if (!(v != null)) {
        v = !this.state.slider;
      }
      this.el.bar.classList[v ? 'add' : 'remove']('active');
      cs = this.getDots();
      if (!v) {
        order = {};
        offsets = this.colors.map(function(d, i){
          return [d.offset, i];
        });
        offsets.sort(function(a, b){
          return b[0] - a[0];
        });
        offsets.map(function(d, i){
          return order[d[1]] = i;
        });
      }
      for (i$ = 0, to$ = cs.length; i$ < to$; ++i$) {
        i = i$;
        n = cs[i];
        idx = n.getAttribute('data-idx');
        n.style.transform = v
          ? "rotate(" + (-60 + 120 * (1 - this.colors[idx].offset)) + "deg)"
          : "rotate(" + (-15 * ((cs.length - 1) * 0.5) + order[idx] * 15) + "deg)";
        n.childNodes[0].setAttribute('fill', ldColor.web(this.colors[idx]));
      }
      return this.state.slider = v;
    }
  });
  ld$.find(document.body, '.ldgradient').map(function(it){
    return new GradientEditor({
      root: it
    });
  });
  if (typeof ldColorPicker != 'undefined' && ldColorPicker !== null) {
    ldcp = new ldColorPicker(null, {
      className: 'flat compact-palette shadow no-alpha'
    });
    ldcp.on('change', function(it){
      if (local.client) {
        return local.client.setColor(it);
      }
    });
    ldcp.on('toggle', function(it){
      return local.client.lock(it);
    });
  }
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}